# 操作系统期中作业

> 201300069 邓嘉宏
>
> email：1739413207@qq.com

## 简答题

### 1.

> 说明抽象资源和物理资源之间的区别，并举出两个例子。

物理资源是指构成计算机的各种物理部件，是系统工作的实体，如：处理器，内存，磁盘，I/O设备等。

抽象资源是操作系统对物理资源的抽象，屏蔽物理资源物理特性和接口细节，简化对物理资源的操作、控制和使用，如：进程、虚拟内存等。

如：将物理资源：处理器、内存和I/O设备抽象成进程；将物理资源：主存、I/O设备抽象成虚拟内存。

### 2. 

>  操作系统有哪些架构，说明各自的特点。

- 单体系统：整个操作系统在内核态以单一程序的方式运行。
- 层次式系统：将单体系统进一步通用化，上层软件都是在下一层软件的基础上构建的。
- 微内核：将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态，其余模块作为普通用户进程运行。作为用户进程的模块崩溃时不会使整个系统死机。
- 客户端-服务器模式：本质是存在客户端进程和服务器进程，客户端和服务器运行在不同的计算机上，他们通过局域网或广域网连接。
- 虚拟机：是裸机硬件的精确复制品，这个复制品包含内核态/用户态、I/O功能、中断及其他真实硬件所应该具有的全部内容。
- 外核：提出库操作系统概念，封装对硬件的抽象，与应用直接连接；操作系统内核只负责对硬件资源在多个库操作系统之间的多路复用支持。

### 3.

> 什么是用户态，什么是内核态，这两种状态如何切换？

用户态：运行在低特权级，只有部分权限，不能访问内核地址空间，只能访问用户程序自己的地址空间。

内核态：运行在高特权级，可以使用计算机所有的硬件资源，访问所有地址空间。

从用户态到内核态：用户态进程触发异常或中断，例如：系统调用、外围设备中断等，从用户态转为内核态进行处理。

从内核态到用户态：异常或中断处理例程结束，从内核态返回用户态。

### 4. 

> 简要描述什么是策略与机制的分离，举例说明。

策略与机制的分离是操作系统设计与实现的一个重要原则，策略编码在用户级软件中，该软件位于内核外部但与内核通信，说明”做什么”；内核中提供了实现这些策略的机制，即”怎么做”。

例如，对于进程调度，一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行具有最高优先级的进程。此时，机制（在内核中）是寻找最高优先级的进程并执行，策略（在用户态中完成）是赋予进程优先级，根据优先级调度进程。

### 5. 

>  什么是进程控制块（PCB），它有哪些主要内容？

PCB是存放进程的管理和控制信息的数据结构。其中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息，一般情况下，PCB中包含：进程 ID、进程状态、程序计数器、CPU 寄存器、内存管理信息、I/O 状态信息和其他信息。

### 6. 

> 简述进程的生命周期。

一个进程主要有五种状态：新建态、就绪态、运行态、阻塞态、终止态。

当进程创建后，它处于新建态，当它获取了足够的资源（内存、文件等）后就流转到了就绪态，被调度执行之后转为运行态，在CPU执行，调度器可以选择中断该进程并放回调度队列，进而进入就绪态；如果该进程需要等待一些外部事件，例如某个 I/O 请求的完成，就进入阻塞态；如果进程在运行的过程中没有任何阻塞，则它会正常退出；但如果它运行过程中有异常，它会异常退出，这两种退出都属于终止态。进程在阻塞态时，等待的外部事件完成后，就会进入就绪态。

### 7.

> 什么是系统调用？简述系统调用流程。

系统调用是一种特殊的”异常事件”，是在用户程序和内核之间一个像过程一样的接口，用户程序利用这个接口可以方便地使用操作系统内核提供的一些服务。

系统调用流程：

1. 用户程序调用标准库函数，标准库函数调用系统调用封装函数，封装函数执行到陷阱指令时从用户态陷入到内核态；
2. 转到内核态执行后，CPU根据陷阱指令执行时EAX寄存器中的系统调用号，选择执行一个相应的系统调用服务例程；
3. 系统调用服务例程执行结束时，通过返回指令从内核态返回到用户态。

### 8.

> 进程间有哪些通信方式，各自有什么特点？

生产者-消费者模式：一个进程的输入是另一个进程的输出，单向通信，生产者只能写，消费者只能读。

服务端-客户端模式：允许进程间双向通信。

文件系统模式：进程间通过读写文件来通信，且通信能在时间上分离。

具体实施后，有管道、信号、共享内存、消息队列、套接字、信号量等通信方式。

### 9.

> 在用户态实现线程的最大优点是什么？最大缺点是什么？

最大优点：创建、销毁不需要系统调用，而且用户空间可以自己维护，因此管理开销小、切换成本小。

最大缺点：与内核协作成本高，如：当进行I/O时，需要频繁进行用户态和内核态的切换。

### 10.

> 内核采取一系列动作以便在两个进程之间进行上下文切换，请描述一下这些过程。

上下文切换发生在操作系统调度一个新进程到处理器上运行时，它需要完成以下三件事：

1. 将当前处理器的寄存器上下文保存到当前进程的系统级上下文的现场信息中；
2. 根据调度算法选择新进程，将新进程系统级上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中；
3. 将控制转移到新进程执行。

### 11.

> 最短作业优先算法在什么情况下是最优的？怎么证明？

当所有任务同时到达，且需要平均周转时间最短时，最短作业优先算法是最优的。

证明：

不失一般性，考虑有n个任务同时到达，需要的执行时间分别为: $a_1, a_2\cdots c_n$，那么, 平均周转时间为：$\displaystyle \frac{n\cdot a_1+ (n-1)\cdot a_2 + \cdots a_n}{n}$，可以发现 $i$ 越小， $a_i$ 使平均周转时间增加越多，所以使 $a_i$ 越小能使平均周转时间越小，所以此时采用最短作业优先算法是最优的。 

### 12.

> 简述实时系统中调度问题的单调速率算法。

单调速率算法采用抢占的、静态优先级的策略，调度周期性任务。每个周期性任务会分配一个优先级，它与其周期成反比，周期越短，优先级越高，也就是说更频繁地需要CPU的任务应分配更高的优先级，当较低优先级的进程正在运行并且较高优先级的进程可以运行时，较高优先级进程将会抢占低优先级。

### 13.

> 怎么解决多级反馈队列调度算法中的饿死问题？

周期性地提升所有任务的优先级，如：经过一段时间，就将系统中所有任务重新加入最高优先级队列。在最高优先级队列中，长任务和其他高优先级任务分享CPU，从而最终获得执行，不会出现饿死问题。

### 14. 

> 什么是虚拟地址（空间）和物理地址（空间）？

物理地址是CPU地址总线传来的地址，由硬件电路控制其对应内存哪个物理位置，这些物理地址的集合就是物理地址空间。

虚拟地址是操作系统对内存进行抽象，采用虚拟内存管理的地址，虚拟地址的集合就是虚拟地址空间，虚拟地址通过MMU转化为物理地址。

### 15.

> 请简述分页式存储管理的基本实现原理。

分页式存储管理中，虚拟地址空间被划分成多个大小相同的页面，物理地址空间也被划分成大小相同的页面，硬盘和主存之间按页面为单位交换信息。采用”请求分页”思想，每次访问指令或数据仅将当前需要的页面从硬盘调入主存某页框中，而进程中其他不活跃的页面保留在硬盘上，当访问某个信息所在页不在主存时发生缺页异常，此时，从硬盘将缺失页面装入主存。虚拟页面和物理页面的对应关系保存在页表，地址转换时，MMU根据虚拟地址在页表中找到物理页号，将它和页内地址组合即得到物理地址。

### 16.

> 假设物理内存足够大，虚拟内存是否还有存在的必要？如果不使用虚拟内存抽象，只使用物理内存寻址，会对操作系统的内存管理带来哪些改变?

有存在的必要。如果只使用物理内存寻址，那么不同进程的内存空间可能会互相覆盖，因为进程可能会使用另一个进程正在使用的物理地址，导致进程不能正确运行；只使用物理内存寻址，那么操作系统所在地址空间容易被访问破坏，安全性降低。

### 17.

> 什么是优先级反转问题？怎么解决？

当一个较高优先级任务通过信号量机制访问共享资源时，该信号量已经被较低优先级任务占有，此时，该高优先级任务不能执行，而这个低优先级任务在访问共享资源时可能又被其它一些中等优先级任务抢先，因此造成高优先级任务被许多具有较低优先级任务阻塞，这就是优先级反转问题。

解决方法：可以采用"优先级天花板"方法解决：当任务申请某资源时， 把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。也可以采用”优先级继承”方法解决：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。

### 18.

> 简述下管程中的Brinch Hansen、Hoare、Mesa语义区别。

考虑如下情况：线程A在条件变量的等待队列中等待资源，此时线程B在该资源上执行signal操作：

Brinch Hansen语义：signal是最后一条语句，signal发生在线程B离开管程的时候，将线程A唤醒放入准备队列，线程B退出管程。

Hoare语义：线程B执行signal之后，迅速唤醒等待中的线程A，自己进入signal队列中，每次有线程退出时，先到signal队列中调度线程，如果signal队列空，才到入口等待队列调度线程。

Mesa语义：线程B执行signal之后，把线程A唤醒放入等待队列，线程B不会立刻退出管程，而是执行到lock.release()之后才进入就绪态。在wait后被唤醒的进程不一定会被立刻调度，必须检查条件是否满足。

### 19. 

>  简要说明Peterson算法的原理，Peterson算法符合safety和liveness性质吗？说明理由。

Peterson算法使用两个控制变量turn和interested, 其中interested[n]的值为真，表示ID号为n的进程希望进入该临界区, 变量turn保存有权访问共享资源的进程的ID号。 算法开始时，interested数组的两个成员变量都被设为0 (False)，表示两个线程都不希望进入临界区。若某线程$i(0或1)$进入临界区之前必须满足两个条件之一：$flag[\neg i] == FALSE$（另一线程不希望进入临界区）或 $turn == i$（$i$有权进入临界区）。

Peterson算法符合safety和liveness性质。

safety：当线程 i 希望进入临界区时，若线程 j 也希望进入临界区，则算法会根据turn的值决定一个线程（i 或 j）进入临界区；若线程 j 已经在临界区内，那么turn的值会指示只有 j 能进入临界区，i 不能进入。因此，不会有两个线程同时进入该临界区，符合safety性质。

liveness：当线程 i 不希望进入临界区或离开临界区时，interested[i] = False，此时线程 j 能进入临界区，不会永远不能进入该临界区，符合liveness性质。

### 20.

> 简要说明信号量、互斥锁、条件变量的区别和联系。

信号量：用在多线程多任务同步，使用一个整型变量来累计唤醒次数，供以后使用。

互斥锁：用在多线程多任务互斥，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才可以利用这个资源。

条件变量：当条件变量满足时，再继续执行，使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时（条件变量被唤醒），所有的线程可以一起恢复执行。

联系：互斥锁是信号量的简化版本，只需要解锁和加锁两种状态，不需要信号量的计数能力，信号量的初始值为1能用作互斥锁，信号量的初始值为 0 能用作条件变量。



## 应用题

### 1.

![](D:\大二_上\Markdown\OS1.jpg)

### 2. 

fork创建一个子进程，并从调用fork函数的点继续执行父进程和子进程。 CreateProcess创建一个新进程并从磁盘加载程序。

#### (a)

fork更合适。fork创建子进程后，子进程可以共享父进程的资源，Shell用fork创建子进程能实现像输出重定向的功能。

#### (b)

fork更合适。Web服务器收到的请求非常相似，利用fork的写时复制机制，即当子进程或者父进程对内存页进行修改时才会进行复制，这样可以减少复制次数，减少资源消耗。

#### (c)

fork更合适。父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端，在调用fork创建子进程，该子进程能继承两个文件描述符，指向同一管道。父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，数据从写端流入从读端流出，这样就实现了管道通信。

### 3.

共创建4个进程。因为fork创建一个子进程，并从调用fork函数的点继续执行父进程和子进程，所以第一个fork后有2个进程，这2个进程分别调用第二个fork后有4个进程。

### 4.

#### (a)

![](D:\大二_上\Markdown\os3.jpg)



![](D:\大二_上\Markdown\os2.jpg)

#### (b)

平均周转时间：

FCFS: $\displaystyle T=\frac{2+3+11+15+20}{5}=10.2ms$;

SJF: $\displaystyle T=\frac{1+3+7+12+20}{5}=8.6ms$;

非抢占式优先级：$\displaystyle T=\frac{8+13+15+19+20}{5}=15ms$;

RR：$\displaystyle T=\frac{2+3+13+18+20}{5}=11.2ms$。

#### (c)

平均等待时间：

FCFS: $\displaystyle T=\frac{0+2+3+11+15}{5}=6.2ms$;

SJF: $\displaystyle T=\frac{0+1+3+7+12}{5}=4.6ms$;

非抢占式优先级：$\displaystyle T=\frac{0+8+13+15+19}{5}=11ms$;

RR：$\displaystyle T=\frac{0+2+12+9+13}{5}=7.2ms$;

所以，SJF的平均等待时间最小。

### 5.

#### (a)

一个I/O密集型任务经过1msCPU计算后，经过20个1ms时间片和21次上下文切换回到该任务，这段时间大于10ms，不会出现I/O等待。

CPU利用率：$\displaystyle \frac{1+20}{21\times 0.1+1+20}=90.9\%$.

#### (b)

一个I/O密集型任务占用1msCPU计算，不满一个时间片，经过20个1ms、1个时间片、21次上下文切换回到该任务，这段时间大于10ms，不会出现I/O等待。

CPU利用率：$\displaystyle \frac{20\times 1+1\times 5}{21\times 0.1+20\times 1+1\times 5}=92.3\%$.

### 6.

P1的优先级1/50大于P2的优先级1/90.

![](D:\大二_上\Markdown\os4.jpg)

如图，在P1和P2的最小公共周期450ms内，能正确执行，所以成功。

### 7.

#### (a)

页面内地址占13位，所以虚拟页号占23位，所以共有$2^{23}$个页面。

#### (b)

可访问的最大物理地址为`0x1fff ffff ffff`，最大物理地址空间大小为64GB。如果每个页表项32位均存放物理页号，拼接上13位页内偏移，共有45位物理地址，所以最大物理地址为`0x1fff ffff ffff`，最大物理地址空间大小为64GB。

#### (c)

考虑页表平均大小：

若采用一级页表：$2^{23}\times 4B=32MB$;

若采用二级页表：将地址划分为12|11|13，$(2^{12}+2^9\times 2^{11})\times 4B=4MB$;

若采用三级页表：将地址划分为8|8|7|13，$(2^{8}+2^{5}\times2^8+2^{13}\times 2^{7})\times 4B=4MB$。

因此选择二级页表，因为它比一级页表占用空间小，地址访问比三级页表更符合逻辑更高效。

### 8.

FIFO: 页面3，因为页面3最早被载入。

第二次机会：页面2，因为页面2是R位为0的页面中最早被载入的。

NRU: 页面2，因为页面2的R位和M位均为0。

LRU：页面1，因为页面1的最近一次访问时间最早。

### 9.

强制轮转法处理第 $i$ 个进程：

```C
while (TRUE) {
  while (turn != i);
  critical_section();
  turn = (i + 1) % n;
  noncritical_section();
}
```



### 10.

```C
int BUFFER_SIZE = 100;
int count = 0;
Condition empty;
Condition full;
int mutex = 0;

void producer(void) {
  int item;
  while (TRUE) {
    produce_item(&item);
    mutex_lock(mutex);
    while (count == BUFFER_SIZE)
      wait(full, mutex); 
    enter_item(item);
    count++;
    signal(empty);
    mutex_unlock(mutex);
  }
}
void consumer(void) {
  int item;
  while (TRUE) {
    mutex_lock(mutex);
    while (count == 0)
      wait(empty, mutex); 
    remove_item(&item);
    count--;
    signal(full);
    mutex_unlock(mutex);
    consume_item(&item);
  }
}
```



