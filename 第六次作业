# 第六次作业

### 201300069 邓嘉宏

## 第七章

### 3

P1和P2并发；P1和P3并发；P1和P4并发；P2和P3并发；P3和P4并发。

### 4

#### （1）

因为第一条指令的地址不在页首，且7条指令在同一页，所以不会发生缺页故障。

#### （2）

执行第1条指令时：数据访问会发生缺页故障，该故障是可恢复的。

​		故障处理过程示意图：

![qq_pic_merged_1640939306925](C:\Users\86134\Documents\Tencent Files\1739413207\FileRecv\MobileFile\qq_pic_merged_1640939306925.jpg)

执行第2条指令：发生缺页故障，是可恢复的。

执行第6条指令时：破坏原来存放在地址0x804a324中的变量k的值。

执行第7条指令时：发生页故障，不可恢复。

​		故障处理示意图：

![qq_pic_merged_1640939746985](C:\Users\86134\Documents\Tencent Files\1739413207\FileRecv\MobileFile\qq_pic_merged_1640939746985.jpg)

#### （3）

会发生”整除0“故障，该故障不可恢复。

### 5

#### （1）

用户态，因为在执行中断指令前执行的都是用户程序的功能。

下个时钟周期，系统从用户态陷入内核态执行。

#### （2）

第5行指令属于陷阱指令。通过系统门描述符来激活异常处理程序，对应的中断类型号是128。P=1，DPL=3，TYPE=1111B。基地址为0，限界为FFFFFH，G=1，S=1，TYPE=1010，DPL=0，D=1，P=1。

#### （3)

第5行指令的执行过程。

① 确定中断类型号为128，从IDTR指向的IDT中取出第128个表项，这个表项实际上就是Linux初始化时在IDT的第128项中设定的系统门描述符。

② 根据IDT中的段选择符，从GDTR指向的GDT中取出相应的段描述符，得到对应异常处理程序或中断服务程序所在段的DPL、基地址等信息。
	检查是否发生了特权级变化，即判断CPL是否与相应段描述符中的DPL不同。因为执行第5行指令时处于用户态，因此CPL=3，而DPL=0，显然此时两者是不同的，故需要从用户态切换至内核态，以使用内核栈保存相关信息。
	通过以下步骤完成用户栈到内核栈的切换:
a）读TR寄存器，以访问正在运行进程的TSS段。
b)  将TSS段中保存的内核栈的段选择符和栈指针分别装入寄存器SS和 ESP，然后在内核栈中保存原来的用户栈的SS和ESP。
③ 将第5行后面一条指令的逻辑地址写入CS和 EIP，以保证内核程序处理后回到下条指令执行。在当前内核栈中保存EFLAGS、CS 和 EIP寄存器的内容。
④ 将IDT中的段选择符（0x60）装入CS，将IDT中的偏移地址装入EIP，它指向内核代码段中的系统调用处理程序system_call的第一条指令。
	这样，从下一个时钟开始，就执行系统调用处理程序system_call的第一条指令。在内核完成系统调用服务后，执行最后一条指令iret，以回到第5行指令的下一条指令继续执行。

## 第八章

### 3

#### （1）

在标准输出设备（文件描述符为stdout)上显示字符串“Hello, world."

#### （2）

执行到第 16、20行的“ int $0x80" 指令时从用户态转到内核态执行。 

#### （3）

调用了系统调用 write、exit。

### 5

#### (1)

因为hello.c中使用了c标准库函数printf()，所以需要加“#include <stdio.h>"。因为在 stdio.h头文件中有printf()函数的原型声明，并且printf()函数是C标准库函数，所以，虽然 hello.c中没有定义printf()函数，也没有它的原型声明，但是通过对hello.c和stdio.h的预处理，编译器会得到printf()的原型声明，从而获得符号printf的相关信息，使得链接器进行链接的时候，能够从标准C库( libc.a或 libc.so）中得到printf模块的信息。

#### (2)

需要经过预处理、编译、汇编、链接才能生成可执行文件 hello，然后通过启动hello程序执行。预处理阶段主要是对带#的语句进行处理;编译阶段主要是将预处理后的源程序文件编译生成汇编语言程序;汇编阶段主要是将汇编语言源程序转换为可重定位的机器语言目标代码文件;链接阶段将多个可重定位的机器语言目标代码以及库函数链接起来，生成最终的可执行文件。

####　(3)

因为printf(）函数默认的输出设备为标准输出设备stdout。

#### (4)

(4)字符串"Hello,world.\n"在机器中对应的0/1序列(机器码是该字符串中每个字符对应的ASCII码，即“48H 65H 6CH 6CH 6FH 2CH 77H 6FH   72H 6CH 64H 0AH 00H"。放在hello.o文件的.rodata节中。在可执行目标文件 hello的只读代码段中。

#### (5)

printf.o模块在静态库libc.a中。.text节被映射到只读代码段中。若采用动态链接，则函数printf()的代码在虚拟地址空间中的共享映射区。

#### (6)

- 被调用者保存寄存器EBX入栈
- 将字符串长度14送EDX
- 将字符串首地址送ECX
- 将文件描述符fd送EBX
- 将调用号4送EAX
- 系统调用入口
- 恢复EBX的旧值
- 系统调用返回值与0xfffff001比
- 大于等于时转出错误处理
- 返回到调用write的过程

返回的最大错误号是4095。

#### (7)

本题程序设计的便携性和可移植性都比较好。第3题程序执行性能最好，因为用汇编实现时，省去高级语言程序中大量的函数调用，因此执行时间最短。

### 7

![IMG_20211231_190643_edit_24087873560385](C:\Users\86134\Documents\Tencent Files\1739413207\FileRecv\MobileFile\IMG_20211231_190643_edit_24087873560385.jpg)

### 13

#### (1)

I/O操作的时间：1.06ms

占整个处理器时间的百分比：5.3%

#### (2)

I/O操作的时间：20ms

占整个处理器时间的百分比：100%

#### (3)

I/O操作的时间：1.202ms

占整个处理器时间的百分比：6.01%

#### (4)

I/O操作的时间：2us

占整个处理器时间的百分比：0.01%

#### (5)

此时，外设传输1000字节所用时间为200us，前3种方式下，CPU所用时间比设备所用时间长得多，因而发生数据丢失，不可行。可行的DMA方式，CPU花在该设备I/O操作上的时间占整个处理器时间的 1%。







