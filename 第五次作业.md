# 第五次作业

### 201300069 邓嘉宏

## 第六章

### 3

#### （1）

$512MB\div64MB=8$, 所以每个内存条需要8个DRAM芯片。

#### （2）

$2\times 2^{10}\div 2^9=4$, 所以需要4个内存条。

#### （3）

主存地址有32位：$A_{31}A_{30}...A_1A_0$。$A_{28}A_{27}...A_4A_3$用作DRAM芯片内地址，$A_{28}A_{27}...A_{17}A_{16}$用作行地址，$A_{15}A_{14}...A_4A_3$用作列地址，$A_2A_1A_0$用于选择芯片。

### 5

平均旋转等待时间：$1000/7200/60/2=4.17ms$

数据块传输时间：$4KB/40MB=0.1024ms$

所以读取总时间：2+10+4.17+0.1024=16.27ms

"读出--处理--写回"时间：$16.27\times 2+20000/500MHz=32.58ms$

每秒次数：$1000/32.58\approx30次$

### 9

#### （1)

此时，主存地址即为主存块号。

用”x-y“表示：x为主存块号，y为cache行号，hit表示命中，miss表示缺失，replace表示替换。

则：2-2，miss； 3-3， miss； 11-11，miss; 16-0，miss；21-5，miss；13-13，miss；64-0，miss/replace；48-0，miss/replace；19-3，miss/replace；11-11，hit；3-3，miss/replace；22-6，miss；4-4，miss；27-11，miss/replace；6-6，miss/replace；11-11，miss/replace。

所以命中率为：1/16=6.25%

#### （2）

此时，cache变为4行，主存块号=主存地址/4。

用”x-y-z“表示：x为主存地址，y为主存块号，z为cache行号，hit表示命中，miss表示缺失，replace表示替换。

则：2-0-0，miss；3-0-0，hit；11-2-2，miss；16-4-0，miss/replace；21-5-1，miss；13-3-3，miss；64-16-0，miss/replace；48-12-0，miss/replace；19-4-0，miss/replace；11-2-2，hit；3-0-0，miss/replace；22-5-1，hit；4-1-1，miss/replace；27-6-2，miss/replace；6-1-1，hit；11-2-2，miss/replace。

所以命中率为：4/16=25%

### 10

```c
int sum_array(int a[N][N][N]){
    int i,j,k,sum=0;
    for (i=0;i<N;i++)
        for(j=0;j<N;j++)
            for(k=0;k<N;k++)
                sum+=a[i][j][k];
    return sum;
}
```

修改后，数组访问的空间局部性更好，cache命中率高，程序执行时间更短。

### 12

#### （1）

因为数组x和y均按存放顺序访问，所以空间局部性好，每个数组元素都被访问一次，没有时间局部性。命中率高低与块大小、cache容量、映射方式有关，现在只根据空间局部性，暂且推断其命中率高。

#### （2）

x[0]~x[3]在同一内存块，x[4] ~ x[7]在同一内存块，y[0] ~ y[3]在同一内存块，y[4] ~ y[7]在同一内存块。且x[0] ~ x[3]和y[0] ~ y[3]都映射到cache的第0行，x[4] ~ x[7]和y[4] ~ y[7]都映射到cache的第1行。所以x[i]和y[i]每次都冲突，命中率为0。

#### （3）

数组的每相邻两个元素在同一内存块，x[i]和y[i]可以存放在同一cache组的不同行，块中的第一个数组元素总是不命中，第二个数组元素总是命中，所以命中率为50%。

#### （4）

数组的每相邻四个元素在同一内存块，x[i]和y[i]存放在cache的不同行，块中的第一个数组元素总是不命中，后面3个数组元素总是命中，所以命中率为75%。

### 13

|       | s      | r      | c      | 数组   | d      | s      | t      | 数组   |
| ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 32B   | col=0  | col=1  | col=2  | col=3  | col=0  | col=1  | col=2  | col=3  |
| row=0 | 0/miss | 0/miss | 0/hit  | 0/miss | 0/miss | 0/miss | 0/miss | 0/miss |
| row=1 | 1/miss | 1/hit  | 1/miss | 1/hit  | 1/miss | 1/miss | 1/miss | 1/miss |
| row=2 | 0/miss | 0/miss | 0/hit  | 0/miss | 0/miss | 0/miss | 0/miss | 0/miss |
| row=3 | 1/miss | 1/hit  | 1/miss | 1/hit  | 1/miss | 1/miss | 1/miss | 1/miss |



|       | s      | r     | c     | 数组  | d      | s     | t     | 数组  |
| ----- | ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- |
| 128B  | col=0  | col=1 | col=2 | col=3 | col=0  | col=1 | col=2 | col=3 |
| row=0 | 4/miss | 4/hit | 4/hit | 4/hit | 0/miss | 0/hit | 0/hit | 0/hit |
| row=1 | 5/miss | 5/hit | 5/hit | 5/hit | 1/miss | 1/hit | 1/hit | 1/hit |
| row=2 | 6/miss | 6/hit | 6/hit | 6/hit | 2/miss | 2/hit | 2/hit | 2/hit |
| row=3 | 7/miss | 7/hit | 7/hit | 7/hit | 3/miss | 3/hit | 3/hit | 3/hit |



### 18

不妨设执行了N条指令。

处理器1：额外开销：$N\times(4\%+6\%\times 50\%)\times (1+6)=0.49N$个时钟周期，总时间：$（N\times2.0+0.49N)\times 420ps=1045.8Nps$。

处理器2：额外开销：$N\times(2\%+4\%\times 50\%)\times (4+6)=0.4N$个时钟周期，总时间：$（N\times2.0+0.4N)\times 420ps=1008Nps$。

处理器3：额外开销：$N\times(2\%+3\%\times 50\%)\times (4+6)=0.35N$个时钟周期，总时间：$（N\times2.0+0.35N)\times 450ps=1057.5Nps$。

所以，处理器1额外开销最大，处理器2的执行速度最快。



### 21

#### （1）

虚拟地址中低7位表示页内偏移量，高9位为虚拟页号。虚拟页号中高7位为TLB标记，低2位为TLB组索引。

#### （2）

物理地址中低7位为页内偏移量，高5位为物理页号。

#### （3）

物理地址中低2位为块内地址，中间4位为cache行索引，高6位为标记。

#### （4）

虚拟地址067AH=0000 0110 0111 1010B，虚拟页号为000001100B，映射到TLB第0组，0000011B=03H与第一个标记相等，但有效位为0，TLB缺失。查慢表得到页框号19H=11001B，并且有效位为1，拼接成物理地址为110011 1110 10B，根据中间四位1110B=EH，cache的E行有效位为1且标记33H=110011B，所以cache命中。最后根据物理地址最低两位10B，从cache中读出该short变量为2D4AH。

### 23

#### （1）

```c
	movl $0, %ecx
.L
    cmpl %ebx, %ecx
    jge  .EXIT
    addl (%edx, %ecx, 4), %eax
    incl %ecx
    jmp  .L
.EXIT
```

#### （2）

PE=1（表示保护模式），PG=1（表示启用分页）

#### （3）

指令 I 的汇编形式：addl(%edx，%ecx，4)，%eax

寻址方式为"基址+比例变址+偏移量"。

#### （4）

指令的线性地址：0x0+0x8049c08=0x8049c08

虚页号为线性地址高20位：0000 1000 0000 0100 1001B

页内偏移量为线性地址低12位：1100 0000 1000B

页目录索引为虚页号的高10位：0000 1000 00B

页表索引为虚页号的低10位：00 0100 1001B

页目录项地址：0x3d000+0x20*4=0x3d080

页表项地址：0x5c8000+0x49*4=0x5c8124

指令地址：0x1020c08

P=1（所在页已在主存），R/W=0（所在页只能读和执行，不能写），U/S=1（允许用户进程访问），A=1（所在页已被访问过），D=0（所在页为代码页，不会被修改）

#### （5）

取指令I不会发生缺页异常，因为在执行指令I之前的指令缺页时会将I一起调入内存。取操作数a[0]时可能发生缺页，因为a[0]位于一个页面的起始处，页故障线性地址为0x804d000，保存在控制寄存器CR2。

#### （6）

取指令I不会发生TLB缺失，取操作数a[0]可能发生TLB缺失，理由同上。

虚页号低2位为TLB组索引，高18位为TLB标记。

指令I的主存地址：0x28b0c08

####  （7）

cache共有256行，组数为128，主存地址的高20位为标记，中间7位为组索引，低5位为块内地址。线性地址的低12位与主存地址的低12位相同，指令 I 的线性地址为0x8049c08，低12位为：1100 0000 1000，所以块内地址为：01000，组索引为：1100000。

因为指令 I 不在一个主存块的起始位置，所以不会发生cache缺失。指令 I 映射到cache的第96组。

#### （8）

此时，数组a占用的空间大小：4*2000=8000字节，8000B/4KB=1.95，a的首地址不在页首，所以占用三个页面。

虚页号为：0000 1000 0000 0100  1001B，0000 1000 0000 0100 1010B和0000 1000 0000 0100 1010B。

4*1200=4800>4096，所以在第二个页面中。

